
" REFERENCE: CTERM COLORS
" --------------------------------
"
" NR-16   NR-8    COLOR NAME
" 0       0       Black
" 1       4       DarkBlue
" 2       2       DarkGreen
" 3       6       DarkCyan
" 4       1       DarkRed
" 5       5       DarkMagenta
" 6       3       Brown, DarkYellow
" 7       7       LightGray, LightGrey, Gray, Grey
" 8       0*      DarkGray, DarkGrey
" 9       4*      Blue, LightBlue
" 10      2*      Green, LightGreen
" 11      6*      Cyan, LightCyan
" 12      1*      Red, LightRed
" 13      5*      Magenta, LightMagenta
" 14      3*      Yellow, LightYellow
" 15      7*      White

" func to run a command and show output in split buffer

function! ExecuteInShell(command, ftype) " {{{
    let command = join(map(split(a:command), 'expand(v:val)'))
    let winnr = bufwinnr('^' . command . '$')
    silent! execute  winnr < 0 ? 'new ' . shellescape(command) : winnr . 'wincmd w'
    execute 'setlocal filetype=' . a:ftype . ' buftype=nowrite bufhidden=wipe nobuflisted noswapfile nowrap nonumber'
    echo 'Execute ' . command . '...'
    silent! execute 'silent %!'. command
    silent! redraw
    "silent! execute 'au BufUnload <buffer> execute bufwinnr(' . bufnr('#') . ') . ''wincmd w'''
    "silent! execute 'nnoremap <silent> <buffer> <LocalLeader>r :call <SID>ExecuteInShell(''' . command . ''')<CR>:AnsiEsc<CR>'
    silent! execute 'nnoremap <silent> <buffer> q :q<CR>'
    silent! execute 'AnsiEsc'
    echo 'Shell command executed: ' . command
endfunction " }}}
command! -complete=shellcmd -nargs=+ Shell call ExecuteInShell(<q-args>, 'shelloutput')


" http://stackoverflow.com/questions/6696079/vimrc-causes-error-e10-should-be-followed-by-or
set nocompatible

" activate pathogen
execute pathogen#infect()


" --------------------------------
" Basic Configuration
" --------------------------------

" obviously...
set encoding=utf-8

function! OpenUniteIfNoFile()
  if argc() == 0
    :Unite file file_rec -no-split
  elseif isdirectory(argv(0))
    :UniteWithCurrentDir file file_rec -no-split
  endif
endfunction

" open unite if VIM is started with no file
"augroup EnterVimNoFile
"  au VimEnter * call OpenUniteIfNoFile()
"augroup end

"augroup CursorLineFix
  "au VimEnter,BufEnter,WinEnter * setlocal cursorline
"augroup end

function! s:simple_buffer_settings()
  nnoremap <buffer> <q> :q<CR>
  inoremap <buffer> <q> :q<CR>
endfunction

augroup EasyQuitForSimpleBuffers
  autocmd FileType help call s:simple_buffer_settings()
augroup end

" alt + right arrow : go to end of line
inoremap <A-right> <end>
nnoremap <A-right> <end>
" alt + left arrow : go to start of line
inoremap <A-left> <home>
nnoremap <A-left> <home>
" move line up
nnoremap <C-S-k> :m -2<CR>
inoremap <C-S-k> :m -2<CR>
" move line down
nnoremap <C-S-j> :m +1<CR>
inoremap <C-S-j> :m +1<CR>

" binds for scrolling/moving
nnoremap <ScrollWheelUp> 8<C-Y>
inoremap <ScrollWheelUp> <C-O>8<C-Y>
nnoremap <ScrollWheelDown> 8<C-E>
inoremap <ScrollWheelDown> <C-O>8<C-E>
nnoremap <S-k>   {
nnoremap <S-j> }
nnoremap <C-j>   <C-U>
inoremap <C-j>   <C-O><C-U>
nnoremap <C-k> <C-D>
inoremap <C-k> <C-O><C-D>

" DISABLE ARROW KEYS
"noremap   <Up>     <NOP>
"noremap   <Down>   <NOP>
"noremap   <Left>   <NOP>
"noremap   <Right>  <NOP>

" Press i to enter insert mode, and ii to exit.
imap ii <Esc>

" save
nnoremap <c-s> :w<CR>
inoremap <c-s> <esc>:w<CR>

" identify highlight group under cursor
map <F9> :echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") . '> trans<'
      \ . synIDattr(synID(line("."),col("."),0),"name") . "> lo<"
      \ . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"<CR>

" activate mouse usage in every mode
set mouse=a

" preview window height
set previewheight=20

" code folding
set foldmethod=indent
set foldlevel=99

" hide unsaved buffers instead of asking to save them
set hidden


" --------------------------------
" general display options
" --------------------------------

" enable syntax highlighting
syntax on

" show line numbers
set number

" highlight current line
set cursorline
"hi CursorLine ctermbg=Black
nnoremap <kPlus> :set cursorline<cr>
inoremap <kPlus> :set cursorline<cr>

" show column highlight @ 80
set colorcolumn=80

" this is required after I compiled vim 7.4 from source, otherwise the
" backspace key doesn't work
set backspace=2

" ignore case in searches excepted if an uppercase letter is used
set ignorecase
set smartcase

" soft wrapping
set wrap

" buffer screen updates to help with large files and/or fast scrolling
set lazyredraw

set incsearch
set hlsearch

" highlight group links
hi link lessVariableValue       Normal
hi link lessParametricMixin     Identifier
hi link cssIdentifier           Identifier
hi link cssTagName              Special
hi link cssPseudoClass          Special
hi link cssBoxProp              Normal
hi link cssColorProp            Normal
hi link cssRenderProp           Normal
hi link cssGeneratedContentProp Normal
hi link cssFontProp             Normal
hi link cssTextProp             Normal
hi link cssTextAttr             Normal

" --------------------------------
" whitespace characters
" --------------------------------

"set listchars=eol:↵,tab:⇥,trail:~,extends:⤵,precedes:⤷,nbsp:․
set listchars=eol:↵,tab:⇥\ ,extends:⤵,precedes:⤷,trail:◦ " •
set list

" NOTE: relevant highlight groups are found
" in either .vimrc-dark or .vimrc-light

" --------------------------------
" indentation
" --------------------------------

" enable file type detection for auto-indent
" @link http://vim.wikia.com/wiki/Indenting_source_code
filetype plugin indent on

" size of a hard tabstop
set tabstop=2

" size of an "indent"
set shiftwidth=2

" a combination of spaces and tabs are used to simulate tab stops at a width other than the (hard)tabstop
set softtabstop=2

" make "tab" insert indents instead of tabs at the beginning of a line
set smarttab

" always uses spaces instead of tab characters
set expandtab


" --------------------------------
" buffers/tabs
" --------------------------------

" tab navigation
nnoremap [ :bprevious<CR>
nnoremap ] :bnext<CR>
inoremap <leader>[ <esc> :bprevious<CR>
inoremap <leader>] <esc> :bnext<CR>

" always show tabs
"set showtabline=2

" Delete buffer while keeping window layout (don't close buffer's windows).
" Version 2008-11-18 from http://vim.wikia.com/wiki/VimTip165
if v:version < 700 || exists('loaded_bclose') || &cp
  finish
endif
let loaded_bclose = 1
if !exists('bclose_multiple')
  let bclose_multiple = 1
endif

" Display an error message.
function! s:Warn(msg)
  echohl ErrorMsg
  echomsg a:msg
  echohl NONE
endfunction

" Command ':Bclose' executes ':bd' to delete buffer in current window.
" The window will show the alternate buffer (Ctrl-^) if it exists,
" or the previous buffer (:bp), or a blank buffer if no previous.
" Command ':Bclose!' is the same, but executes ':bd!' (discard changes).
" An optional argument can specify which buffer to close (name or number).
function! s:Bclose(bang, buffer)
  if empty(a:buffer)
  let btarget = bufnr('%')
  elseif a:buffer =~ '^\d\+$'
  let btarget = bufnr(str2nr(a:buffer))
  else
  let btarget = bufnr(a:buffer)
  endif
  if btarget < 0
  call s:Warn('No matching buffer for '.a:buffer)
  return
  endif
  if empty(a:bang) && getbufvar(btarget, '&modified')
  call s:Warn('No write since last change for buffer '.btarget.' (use :Bclose!)')
  return
  endif
  " Numbers of windows that view target buffer which we will delete.
  let wnums = filter(range(1, winnr('$')), 'winbufnr(v:val) == btarget')
  if !g:bclose_multiple && len(wnums) > 1
  call s:Warn('Buffer is in multiple windows (use ":let bclose_multiple=1")')
  return
  endif
  let wcurrent = winnr()
  for w in wnums
  execute w.'wincmd w'
  let prevbuf = bufnr('#')
  if prevbuf > 0 && buflisted(prevbuf) && prevbuf != w
  buffer #
  else
  bprevious
  endif
  if btarget == bufnr('%')
  " Numbers of listed buffers which are not the target to be deleted.
  let blisted = filter(range(1, bufnr('$')), 'buflisted(v:val) && v:val != btarget')
  " Listed, not target, and not displayed.
  let bhidden = filter(copy(blisted), 'bufwinnr(v:val) < 0')
  " Take the first buffer, if any (could be more intelligent).
  let bjump = (bhidden + blisted + [-1])[0]
  if bjump > 0
  execute 'buffer '.bjump
  else
  execute 'enew'.a:bang
  endif
  endif
  endfor
  execute 'bdelete'.a:bang.' '.btarget
  execute wcurrent.'wincmd w'
  endfunction
command! -bang -complete=buffer -nargs=? Bclose call <SID>Bclose('<bang>', '<args>')

nnoremap <leader>w :Bclose<CR>

" --------------------------------
" --------------------------------
" plugin config/options
" --------------------------------
" --------------------------------


" NERDTree
" --------------------------------

function! StartupNERDTree()
  if 0 == argc()
    NERDTree
  elseif argv(0) != '.'
    NERDTreeFind
  endif
endfunction

" open NERDTree automatically
"autocmd vimenter * NERDTreeFind | wincmd p
"autocmd vimenter * call StartupNERDTree() | wincmd p

" highlight currently open file in NERDTree
"autocmd BufEnter * if &modifiable | NERDTreeFind | wincmd p | endif

" close vim if NERDTree is the only window left
autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTreeType") && b:NERDTreeType == "primary") | q | endif

" bind key to open NERDTree
nnoremap <leader>' :NERDTreeToggle<CR>

" always show hidden files
let NERDTreeShowHidden = 1

let NERDTreeMouseMode = 2
let NERDTreeShowBookmarks = 1
let NERDTreeWinSize = 28
"let NERDTreeMinimalUI = 1


" vim-airline
" --------------------------------

" always show vim-airline
set laststatus=2

let g:airline_powerline_fonts = 0
let g:airline_detect_modified=1
let g:airline_detect_paste=1
let g:airline_detect_iminsert=0
let g:airline_exclude_preview = 0
" enable airline's tabline
let g:airline#extensions#tabline#enabled = 1
" disable showing tab type (far right)
let g:airline#extensions#tabline#show_tab_type = 1
" configure whether close button should be shown
let g:airline#extensions#tabline#show_close_button = 0

" configure truncating non-active buffer names to specified length
"let g:airline#extensions#tabline#fnametruncate = 12

" configure collapsing parent directories in buffer name
"let g:airline#extensions#tabline#fnamecollapse = 0

" configure whether buffer numbers should be shown
let g:airline#extensions#tabline#buffer_nr_show = 1

" enable/disable displaying index of the buffer
let g:airline#extensions#tabline#buffer_idx_mode = 0

"let g:airline#extensions#tabline#formatter = 'unique_tail'
let g:airline#extensions#tabline#fnamemod = ':t'


" git-gutter
" --------------------------------

highlight GitGutterAdd          ctermfg=Green
highlight GitGutterChange       ctermfg=Yellow
highlight GitGutterDelete       ctermfg=Red
highlight GitGutterChangeDelete ctermfg=Red

let g:gitgutter_sign_added =                '✚' " ☑
let g:gitgutter_sign_modified =             '✱' " ⁕ ⁂ ✳ ⋇ ✸ ✱ ✰ ✪ ❋ ❊ ⚫
let g:gitgutter_sign_removed =              '✂' " ✖ ✘ ✗ ✕ ⚑ ⚊ ☒
let g:gitgutter_sign_removed_first_line =   '▔'
let g:gitgutter_sign_modified_removed =     '✱▁'


" unite
" -------------------------------

" enable history yank source
let g:unite_source_history_yank_enable = 1

" shorten the default update date of 500ms
"let g:unite_update_time = 300

" highlight like my vim
let g:unite_cursor_line_highlight = 'CursorLine'

" set up coolguy arrow prompt
let g:unite_prompt = '➜ '

" use the fuzzy matcher for everything
call unite#filters#matcher_default#use(['matcher_fuzzy'])

" use the rank sorter for everything
call unite#filters#sorter_default#use(['sorter_rank'])

" use ack in unite grep source.
if executable('ack-grep')
  let g:unite_source_grep_command = 'ack-grep'
  let g:unite_source_grep_default_opts = '-i --no-color --noheading --nobreak
                                      \ --type-add=css=.less
                                      \ --ignore-dir=node_modules
                                      \ --ignore-dir=vendor
                                      \ --ignore-dir=user-docs
                                      \ --pager="sed s,$PWD,\<pwd\>,g"'
  let g:unite_source_grep_recursive_opt = '-R'
  let g:unite_source_rec_async_command = 'ack -f --nofilter'
endif

" set up some custom ignores
call unite#custom_source('file_rec,file_rec/async,file_rec/git,file_mru,file,buffer,grep',
      \ 'ignore_pattern', join([
      \ '\.git/',
      \ 'node_modules/',
      \ 'vendor/',
      \ 'Vendor/',
      \ ], '\|'))

" KEY BINDINGS
nnoremap <leader>o :Unite file_rec/git<cr>
nnoremap <leader>O :Unite file/async<cr>
nnoremap <leader>f :Unite grep:.<cr>
nnoremap <C-p> :Unite history/yank<cr>
nnoremap <leader>p :Unite history/yank<cr>

" custom mappings for unite buffer
augroup UniteSettings
  autocmd FileType unite call s:unite_settings()
augroup end

function! s:unite_settings()
  imap <buffer><expr> <tab> unite#do_action('tabopen')
  nmap <buffer><expr> <tab> unite#do_action('tabopen')
  "nmap <buffer> <ESC> <Plug>(unite_exit)
  imap <buffer><expr> <c-right> unite#do_action('right')
  nmap <buffer><expr> <c-right> unite#do_action('right')
  imap <buffer><expr> <c-left> unite#do_action('left')
  nmap <buffer><expr> <c-left> unite#do_action('left')
endfunction

call unite#custom#profile('default', 'context', {
  \ 'winheight' : 15,
  \ 'start_insert' : 1,
  \ 'prompt_visible': 1,
  \ 'marked_icon': '✓',
  \ 'candidtate_icon': '▸',
  \ 'no_hide_icon': 1,
  \ 'short_source_names': 1,
  \ })


" delimitMate
" -------------------------------

" expand CR
let delimitMate_expand_cr = 1

" expand spaces
let delimitMate_expand_space = 0


" TagBar
" -------------------------------

nmap <leader>t :TagbarToggle<CR>

"autocmd FileType javascript,less,html nested :TagbarOpen


" Limelight 
" -------------------------------

let g:limelight_conceal_ctermfg = 10

nmap <Leader>l <Plug>(Limelight)


" Fugitive (Git wrapper)
" -------------------------------

nmap <leader>gs :Gstatus<CR>
nmap <leader>ga :Git add %:p<CR><CR>
nmap <leader>gc :Gcommit -v<CR>
nmap <leader>gd :call ExecuteInShell('git diff --color %:p', 'gitdiff')<CR>:set number<CR>:set nocursorline<CR>
nmap <leader>gD :call ExecuteInShell('git diff --color', 'gitdiff')<CR>:set number<CR>:set nocursorline<CR>
nmap <leader>gl :call ExecuteInShell('git lg -20', 'gitlog')<CR>
nmap <leader>gL :call ExecuteInShell('git lg', 'gitlog')<CR>
" no color version:
"nmap <leader>gl :call ExecuteInShell('git log --pretty=oneline --graph --all --decorate --abbrev-commit', 'gitlog')<CR>

"augroup FugitiveBinds
"  autocmd FileType gitcommit call s:fugitive_binds()
"augroup end

"function! s:fugitive_binds()
"  nnoremap <buffer> <silent> + :<C-U>silent execute <SID>StageToggle(line('.'),line('.')+v:count1-1)<CR>
"endfunction


" TODO: figure out a way to automatically do this, without inversion like the
" old 'vimrc-main' scheme...
set background=dark

"if (&background == "dark")
"  source ~/.vimrc-dark
"else
"  source ~/.vimrc-light
"endif


set t_Co=256

"let g:airline_theme='theme_dark'
let g:airline_theme='solarized'

"let g:seoul256_background = 236
colorscheme solarized

"source ~/.vimrc-dark
